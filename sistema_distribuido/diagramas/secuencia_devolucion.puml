@startuml
!theme plain
title Diagrama de Secuencia - Flujo de Devolución de Libros

skinparam sequence {
  BackgroundColor LightBlue
  BorderColor DarkBlue
  ArrowColor DarkGreen
  LifeLineBackgroundColor LightYellow
  LifeLineBorderColor DarkOrange
}

participant "Proceso\nSolicitante" as PS
participant "Gestor de\nCarga" as GC
participant "Actor\nDevolución" as AD
participant "Base de\nDatos" as BD
participant "Sistema de\nLogs" as LOG

== Flujo de Devolución de Libro ==

PS -> PS : leer_solicitudes("data/solicitudes.txt")
PS -> PS : parsear_linea("DEVOLUCION L001 U001 SEDE_1")
PS -> PS : crear_mensaje_json()

note over PS
**Solicitud preparada**
Operación: DEVOLUCION
Libro: L001, Usuario: U001, Sede: SEDE_1
end note

== Comunicación REQ/REP (Síncrona) ==

PS -> GC : req_socket.send(solicitud_json) [REQ]
note right of PS
**Puerto 5001**
Patrón REQ/REP
Comunicación síncrona
end note

GC -> GC : rep_socket.recv(zmq.NOBLOCK) [REP]
GC -> GC : procesar_solicitud()
GC -> GC : json.loads(mensaje_json)
GC -> GC : validar_operacion("DEVOLUCION")
GC -> GC : datetime.utcnow().isoformat()

note over GC
**Evento creado**
Timestamp: 2025-01-XX
Operación: DEVOLUCION
end note

GC -> PS : rep_socket.send(respuesta_json) [REP]
PS -> PS : req_socket.recv()
PS -> PS : json.loads(respuesta_str)
PS -> LOG : log("Solicitud enviada exitosamente")

note over PS
**Respuesta recibida**
Status: OK
Procesando...
end note

== Comunicación PUB/SUB (Asíncrona) ==

GC -> GC : enviar_evento_a_actores()
GC -> AD : pub_socket.send_multipart([b"devolucion", evento_json]) [PUB]
note right of GC
**Puerto 5002**
Patrón PUB/SUB
Topic: "devolucion"
end note

AD -> AD : sub_socket.recv_multipart(zmq.NOBLOCK) [SUB]
AD -> AD : json.loads(datos_json)
AD -> LOG : log("Evento de devolución recibido")

== Procesamiento de Devolución ==

AD -> AD : procesar_devolucion(evento)
AD -> BD : cargar_libros()
BD --> AD : return(base_datos)

note over AD
**Base de datos cargada**
Estado actual de libros
Lista para modificar
end note

AD -> AD : buscar_libro_en_ejemplares("L001")
AD -> AD : verificar_ejemplar_prestado()

alt Si ejemplar encontrado
  AD -> AD : marcar_ejemplar_disponible()
  AD -> AD : ejemplar['estado'] = 'disponible'
  AD -> AD : incrementar_ejemplares_disponibles()
  AD -> AD : decrementar_ejemplares_prestados()

  note over AD
  **Ejemplar devuelto**
  L001: ejemplar disponible
  Contadores actualizados
  end note

  AD -> BD : shutil.copy2(archivo, backup)
  AD -> BD : guardar_libros(base_datos)
  AD -> LOG : log("Devolución procesada exitosamente")

  note over BD
  **Base de datos actualizada**
  Backup creado
  Cambios persistidos
  end note

else Si ejemplar no encontrado
  AD -> LOG : log("WARNING: No se encontró ejemplar prestado")
  AD -> AD : return(False)
end

== Finalización ==

AD -> AD : incrementar_contador_devoluciones()
AD -> LOG : log("Total devoluciones: X")
PS -> PS : incrementar_contador_exitosos()

note over PS,AD
**Devolución completada**
Ejemplares disponibles +1
Sistema actualizado
end note

== Casos de Error en Devolución ==

alt Si error de conexión
  PS -> GC : send(solicitud_json) [REQ]
  GC --> PS : return(timeout_error) [REP]
  PS -> LOG : log("ERROR: No se pudo conectar al GC")
  PS -> PS : incrementar_contador_errores()
end

alt Si error en procesamiento
  AD -> AD : procesar_devolucion(evento)
  AD -> BD : cargar_libros()
  BD --> AD : return(file_not_found_error)
  AD -> LOG : log("ERROR: No se pudo cargar BD")
  AD -> AD : incrementar_contador_errores()
end

alt Si error de validación
  GC -> GC : validar_operacion("INVALID_OP")
  GC -> PS : send(error_response) [REP]
  PS -> LOG : log("ERROR: Operación inválida")
  PS -> PS : incrementar_contador_errores()
end

@enduml